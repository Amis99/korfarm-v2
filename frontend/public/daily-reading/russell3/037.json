{
  "contentId": "dr-r3-037",
  "contentType": "DAILY_READING",
  "version": 1,
  "status": "PUBLISHED",
  "title": "독해(비문학) Day 37",
  "description": "일일 독해 - 정독·복기·확인",
  "targetLevel": "RUSSELL_3",
  "schoolGradeRange": {
    "min": 9,
    "max": 9
  },
  "area": "READING",
  "subArea": "NONFICTION",
  "competencies": [
    "READING"
  ],
  "tags": [
    "daily"
  ],
  "access": {
    "mode": "FREE"
  },
  "seedReward": {
    "seedType": "WHEAT",
    "count": 3,
    "multiplier": 1
  },
  "timeLimitSec": 300,
  "assets": {},
  "payload": {
    "passage": {
      "format": "TEXT",
      "paragraphs": [
        {
          "id": "p1",
          "text": "인터넷의 발달로 데이터 저장 및 분석 과정이 인터넷상에서 이루어지고 있으며 그에 따라 개인정보와 같은 민감한 데이터는 암호화되어 인터넷 서버에 저장된다. 그런데 현재 널리 사용되는 공개키 암호화 방식으로 암호화된 데이터는 통계 처리를 위한 연산을 수행하기 위해서 원래 데이터로 복원하는 복호화 과정을 거친 후 연산을 수행하고 그 결과를 다시 암호화해야 한다. 하지만 이 과정에서 비밀키나 민감한 개인정보가 유출되는 일이 생길 수 있다. 그래서 암호화된 데이터를 복호화하지 않고 암호화된 상태로 안전하게 연산을 수행할 수 있는 동형암호가 등장하였다.\n동형암호는 동형성을 기반으로 하는데, 동형성이란 데이터를 암호화한 상태에서 특정 연산을 수행했을 때 나오는 결과가 암호화하지 않은 상태에서 같은 연산을 수행하고 암호화를 한 결과와 같은 것을 말한다. 이때 연산의 횟수에 제한 없이 특정한 한 종류의 연산에만 동형성을 갖는 암호를 부분 동형암호, 연산의 종류와 관계없이 특정 횟수까지만 동형성을 갖는 암호를 제한적 동형암호라고 하며, 횟수에 제한 없이 컴퓨터의 주된 연산인 덧셈, 곱셈에 동형성을 갖는 암호를 완전 동형암호라고 한다.\n완전 동형암호는 암호화에 사용하는 원리에 따라 격자 기반, CRT(Chinese Remainder Theorem) 기반 등으로 나뉜다. 그중 격자 기반 완전 동형암호는 수학계에서 답을 찾기 어렵다고 알려진 격자 문제를 응용하여 만들어졌다. 이 방식은 원문 데이터를 비트* 단위로 변환하고 각각의 비트를 개별적으로 암호화한다. 암호키 p와 임의의 정수를 곱한 수를 원문에 더하면 암호문이 만들어지는데, 이 과정에서 무작위로 오륫값을 추가하여 안전성을 높인다. 그래서 암호문의 연산을 반복할수록 오륫값이 커지게 되며, 특히 곱셈 연산을 수행할수록 오륫값이 급격하게 커지기 때문에 일정 횟수 이상 수행하면 원문 복호화가 불가능하다.\n따라서 연산을 지속적으로 수행하기 위해서는 오륫값이 한계치에 이른 암호문은 부트스트래핑 과정을 반드시 거쳐야 한다. 일정 횟수의 덧셈과 곱셈 연산을 수행하여 암호문에 오륫값이 누적되면, 다른 암호키로 해당 암호문과 암호키 p를 암호화한다. 그리고 복호화 회로를 통해 기존의 암호키 p에 의한 이전 암호문을 복호화하면 그동안의 연산 과정에서 누적된 오륫값이 제거된 새로운 암호문이 만들어진다. 이때 새로운 암호문이 만들어지면서 오륫값이 추가되지만 그 크기가 기존의 누적된 것보다 작아서 적절하게 부트스트래핑 과정을 수행한다면 지속적인 연산이 가능하다.\n이 방식은 원문을 비트 단위로 변환하여 각 비트별로 암호화하기 때문에 원문에 비해 암호문의 값이 10~100배가량 커져서 데이터의 저장 공간이 많이 필요하다. 그리고 개별 비트 단위로 암호문의 연산과 부트스트래핑 과정을 거쳐야 하기 때문에 연산 속도가 느리다.\n그래서 최근에는 효율성을 개선한 CRT 기반 완전 동형암호가 등장하였다. 이 방식은 하나의 원문을 특정한 정수인 암호키로 나눈 나머지 값을 암호문으로 이용하고, 이 나머지 값에서 원문을 복호화하는 방법이다. 이때 암호키의 개수는 임의로 설정할 수 있으며 각각의 원문마다 암호키의 개수만큼 암호문이 만들어진다. 암호키가 두 개일 때 정수로 된 원문 A와 B를 덧셈 연산한 결과가 동형성을 갖는 원리를 간단히 알아보자. 우선 서로소*인 임의의 정수 p와 q를 암호키로 정하고 정수로 된 원문 A와 B를 각각의 암호키로 나눈 나머지 값을 구하면 Ap, Aq와 Bp, Bq가 되는데 이 나머지 값이 원문 A와 B의 암호문이 된다. 그리고 <그림>처럼 각 원문을 동일한 암호키로 나눈 나머지 값인 Ap와 Bp, Aq와 Bq끼리 서로 덧셈 연산을 수행한다. 만약 연산 수행의 결괏값이 암호키와 같거나 암호키보다 크면 한 번 더 암호키로 나누어 나머지 값을 구한다. 그러면 연산 수행의 결괏값인 Ap+Bp, Aq+Bq가 원문 A와 B를 직접 덧셈 연산한 결괏값을 암호키 p와 q로 나눈 나머지 값인 (A+B)p, (A+B)q와 같다. 그리고 원문을 각 암호키로 나누었을 때의 나머지 값과 각 암호키를 알면 원문을 복호화할 수 있다."
        },
        {
          "id": "p2",
          "text": "<그림>\n(원문 연산: A + B \\= A+B)\n(암호 연산: Ap + Bp \\= (A+B)p / Aq + Bq \\= (A+B)q)\n(Ap, Bp는 p로 나눈 나머지, Aq, Bq는 q로 나눈 나머지)"
        },
        {
          "id": "p3",
          "text": "이 방식 또한 안전성을 위해서 암호키의 개수를 늘려 계산이 복잡하고 무작위로 오륫값을 추가하기 때문에 부트스트래핑 과정이 필요하다. 하지만 데이터를 정수 단위로 암호화하기 때문에 비트 단위로 암호화하는 격자 기반의 방식보다 더 많은 데이터를 저장할 수 있다. 또한 CRT 방식은 원문보다 작은 나머지 값으로 연산을 수행하기 때문에 격자 기반의 방식에 비해 연산 값이 상대적으로 작아 연산 속도가 빠르고, 격자 기반의 방식과 달리 병렬적으로 연산을 수행할 수 있다."
        },
        {
          "id": "p4",
          "text": "* 비트: 정보량의 최소 기본 단위. 1비트는 이진수 체계(0, 1)의 한 자리.\n* 서로소: 여러 개의 수 사이에 1 이외의 공약수가 없음을 이르는 말."
        }
      ]
    },
    "intensive": {
      "timeline": [
        {
          "stepId": "s1",
          "highlight": {
            "paragraphId": "p1",
            "range": {
              "start": 5,
              "end": 8
            }
          },
          "question": {
            "prompt": "하이라이트된 말의 문장 성분으로 가장 알맞은 것은?",
            "choices": [
              {
                "id": "A",
                "text": "주어"
              },
              {
                "id": "B",
                "text": "부사어"
              },
              {
                "id": "C",
                "text": "서술어"
              },
              {
                "id": "D",
                "text": "목적어"
              }
            ],
            "answerId": "B",
            "scoring": {
              "correctDeltaSec": 20,
              "wrongDeltaSec": -20,
              "eliminateWrongChoice": true
            }
          }
        },
        {
          "stepId": "s2",
          "highlight": {
            "paragraphId": "p1",
            "range": {
              "start": 0,
              "end": 85
            }
          },
          "question": {
            "prompt": "하이라이트된 문장의 내용으로 알맞은 것은?",
            "choices": [
              {
                "id": "A",
                "text": "인터넷의 발달로 데이터 저장 및 분석 과정이 인터넷상에서 이루어지고 있으며 그에 따라 개인정보와 같은 민감한 데이터는 암호화되어 인터넷 서버에 저장된다."
              },
              {
                "id": "B",
                "text": "1비트는 이진수 체계(0, 1)의 한 자리."
              },
              {
                "id": "C",
                "text": "또한 CRT 방식은 원문보다 작은 나머지 값으로 연산을 수행하기 때문에 격자 기반의 방식에 비해 연산 값이 상대적으로 작아 연산 속도가 빠르고, 격자 기반의"
              },
              {
                "id": "D",
                "text": "그래서 최근에는 효율성을 개선한 CRT 기반 완전 동형암호가 등장하였다."
              }
            ],
            "answerId": "A",
            "scoring": {
              "correctDeltaSec": 20,
              "wrongDeltaSec": -20,
              "eliminateWrongChoice": true
            }
          }
        },
        {
          "stepId": "s3",
          "highlight": {
            "paragraphId": "p1",
            "range": {
              "start": 86,
              "end": 200
            }
          },
          "question": {
            "prompt": "하이라이트된 문장의 내용으로 알맞은 것은?",
            "choices": [
              {
                "id": "A",
                "text": "그리고 개별 비트 단위로 암호문의 연산과 부트스트래핑 과정을 거쳐야 하기 때문에 연산 속도가 느리다."
              },
              {
                "id": "B",
                "text": "하지만 데이터를 정수 단위로 암호화하기 때문에 비트 단위로 암호화하는 격자 기반의 방식보다 더 많은 데이터를 저장할 수 있다."
              },
              {
                "id": "C",
                "text": "그런데 현재 널리 사용되는 공개키 암호화 방식으로 암호화된 데이터는 통계 처리를 위한 연산을 수행하기 위해서 원래 데이터로 복원하는 복호화 과정을 거친 후"
              },
              {
                "id": "D",
                "text": "그리고 원문을 각 암호키로 나누었을 때의 나머지 값과 각 암호키를 알면 원문을 복호화할 수 있다."
              }
            ],
            "answerId": "C",
            "scoring": {
              "correctDeltaSec": 20,
              "wrongDeltaSec": -20,
              "eliminateWrongChoice": true
            }
          }
        },
        {
          "stepId": "s4",
          "highlight": {
            "paragraphId": "p1",
            "range": {
              "start": 201,
              "end": 204
            }
          },
          "question": {
            "prompt": "하이라이트된 접속어가 나타내는 관계로 가장 적절한 것은?",
            "choices": [
              {
                "id": "A",
                "text": "첨가"
              },
              {
                "id": "B",
                "text": "인과"
              },
              {
                "id": "C",
                "text": "예시"
              },
              {
                "id": "D",
                "text": "대조"
              }
            ],
            "answerId": "D",
            "scoring": {
              "correctDeltaSec": 20,
              "wrongDeltaSec": -20,
              "eliminateWrongChoice": true
            }
          }
        },
        {
          "stepId": "s5",
          "highlight": {
            "paragraphId": "p1",
            "range": {
              "start": 201,
              "end": 243
            }
          },
          "question": {
            "prompt": "하이라이트된 문장의 내용으로 알맞은 것은?",
            "choices": [
              {
                "id": "A",
                "text": "하지만 이 과정에서 비밀키나 민감한 개인정보가 유출되는 일이 생길 수 있다."
              },
              {
                "id": "B",
                "text": "이 방식은 원문을 비트 단위로 변환하여 각 비트별로 암호화하기 때문에 원문에 비해 암호문의 값이 10~100배가량 커져서 데이터의 저장 공간이 많이 필요하다."
              },
              {
                "id": "C",
                "text": "완전 동형암호는 암호화에 사용하는 원리에 따라 격자 기반, CRT(Chinese Remainder Theorem) 기반 등으로 나뉜다."
              },
              {
                "id": "D",
                "text": "그러면 연산 수행의 결괏값인 Ap+Bp, Aq+Bq가 원문 A와 B를 직접 덧셈 연산한 결괏값을 암호키 p와 q로 나눈 나머지 값인 (A+B)p, (A+B)q와"
              }
            ],
            "answerId": "A",
            "scoring": {
              "correctDeltaSec": 20,
              "wrongDeltaSec": -20,
              "eliminateWrongChoice": true
            }
          }
        },
        {
          "stepId": "s6",
          "highlight": {
            "paragraphId": "p1",
            "range": {
              "start": 244,
              "end": 247
            }
          },
          "question": {
            "prompt": "하이라이트된 접속어가 나타내는 관계로 가장 적절한 것은?",
            "choices": [
              {
                "id": "A",
                "text": "대조"
              },
              {
                "id": "B",
                "text": "첨가"
              },
              {
                "id": "C",
                "text": "예시"
              },
              {
                "id": "D",
                "text": "인과"
              }
            ],
            "answerId": "D",
            "scoring": {
              "correctDeltaSec": 20,
              "wrongDeltaSec": -20,
              "eliminateWrongChoice": true
            }
          }
        },
        {
          "stepId": "s7",
          "highlight": {
            "paragraphId": "p1",
            "range": {
              "start": 244,
              "end": 306
            }
          },
          "question": {
            "prompt": "하이라이트된 문장의 내용으로 알맞은 것은?",
            "choices": [
              {
                "id": "A",
                "text": "완전 동형암호는 암호화에 사용하는 원리에 따라 격자 기반, CRT(Chinese Remainder Theorem) 기반 등으로 나뉜다."
              },
              {
                "id": "B",
                "text": "(Ap, Bp는 p로 나눈 나머지, Aq, Bq는 q로 나눈 나머지)"
              },
              {
                "id": "C",
                "text": "그리고 원문을 각 암호키로 나누었을 때의 나머지 값과 각 암호키를 알면 원문을 복호화할 수 있다."
              },
              {
                "id": "D",
                "text": "그래서 암호화된 데이터를 복호화하지 않고 암호화된 상태로 안전하게 연산을 수행할 수 있는 동형암호가 등장하였다."
              }
            ],
            "answerId": "D",
            "scoring": {
              "correctDeltaSec": 20,
              "wrongDeltaSec": -20,
              "eliminateWrongChoice": true
            }
          }
        },
        {
          "stepId": "s8",
          "highlight": {
            "paragraphId": "p1",
            "range": {
              "start": 307,
              "end": 418
            }
          },
          "question": {
            "prompt": "하이라이트된 문장의 내용으로 알맞은 것은?",
            "choices": [
              {
                "id": "A",
                "text": "또한 CRT 방식은 원문보다 작은 나머지 값으로 연산을 수행하기 때문에 격자 기반의 방식에 비해 연산 값이 상대적으로 작아 연산 속도가 빠르고, 격자 기반의"
              },
              {
                "id": "B",
                "text": "인터넷의 발달로 데이터 저장 및 분석 과정이 인터넷상에서 이루어지고 있으며 그에 따라 개인정보와 같은 민감한 데이터는 암호화되어 인터넷 서버에 저장된다."
              },
              {
                "id": "C",
                "text": "<그림> (원문 연산: A + B \\= A+B)"
              },
              {
                "id": "D",
                "text": "동형암호는 동형성을 기반으로 하는데, 동형성이란 데이터를 암호화한 상태에서 특정 연산을 수행했을 때 나오는 결과가 암호화하지 않은 상태에서 같은 연산을 수행하고"
              }
            ],
            "answerId": "D",
            "scoring": {
              "correctDeltaSec": 20,
              "wrongDeltaSec": -20,
              "eliminateWrongChoice": true
            }
          }
        },
        {
          "stepId": "s9",
          "highlight": {
            "paragraphId": "p1",
            "range": {
              "start": 419,
              "end": 576
            }
          },
          "question": {
            "prompt": "하이라이트된 문장의 내용으로 알맞은 것은?",
            "choices": [
              {
                "id": "A",
                "text": "이때 연산의 횟수에 제한 없이 특정한 한 종류의 연산에만 동형성을 갖는 암호를 부분 동형암호, 연산의 종류와 관계없이 특정 횟수까지만 동형성을 갖는 암호를"
              },
              {
                "id": "B",
                "text": "동형암호는 동형성을 기반으로 하는데, 동형성이란 데이터를 암호화한 상태에서 특정 연산을 수행했을 때 나오는 결과가 암호화하지 않은 상태에서 같은 연산을 수행하고"
              },
              {
                "id": "C",
                "text": "* 비트: 정보량의 최소 기본 단위."
              },
              {
                "id": "D",
                "text": "그래서 암호문의 연산을 반복할수록 오륫값이 커지게 되며, 특히 곱셈 연산을 수행할수록 오륫값이 급격하게 커지기 때문에 일정 횟수 이상 수행하면 원문 복호화가"
              }
            ],
            "answerId": "A",
            "scoring": {
              "correctDeltaSec": 20,
              "wrongDeltaSec": -20,
              "eliminateWrongChoice": true
            }
          }
        },
        {
          "stepId": "s10",
          "highlight": {
            "paragraphId": "p1",
            "range": {
              "start": 577,
              "end": 652
            }
          },
          "question": {
            "prompt": "하이라이트된 문장의 내용으로 알맞은 것은?",
            "choices": [
              {
                "id": "A",
                "text": "그중 격자 기반 완전 동형암호는 수학계에서 답을 찾기 어렵다고 알려진 격자 문제를 응용하여 만들어졌다."
              },
              {
                "id": "B",
                "text": "이때 새로운 암호문이 만들어지면서 오륫값이 추가되지만 그 크기가 기존의 누적된 것보다 작아서 적절하게 부트스트래핑 과정을 수행한다면 지속적인 연산이 가능하다."
              },
              {
                "id": "C",
                "text": "완전 동형암호는 암호화에 사용하는 원리에 따라 격자 기반, CRT(Chinese Remainder Theorem) 기반 등으로 나뉜다."
              },
              {
                "id": "D",
                "text": "이 방식은 원문을 비트 단위로 변환하여 각 비트별로 암호화하기 때문에 원문에 비해 암호문의 값이 10~100배가량 커져서 데이터의 저장 공간이 많이 필요하다."
              }
            ],
            "answerId": "C",
            "scoring": {
              "correctDeltaSec": 20,
              "wrongDeltaSec": -20,
              "eliminateWrongChoice": true
            }
          }
        },
        {
          "stepId": "s11",
          "highlight": {
            "paragraphId": "p1",
            "range": {
              "start": 653,
              "end": 710
            }
          },
          "question": {
            "prompt": "하이라이트된 문장의 내용으로 알맞은 것은?",
            "choices": [
              {
                "id": "A",
                "text": "이 방식은 하나의 원문을 특정한 정수인 암호키로 나눈 나머지 값을 암호문으로 이용하고, 이 나머지 값에서 원문을 복호화하는 방법이다."
              },
              {
                "id": "B",
                "text": "그리고 원문을 각 암호키로 나누었을 때의 나머지 값과 각 암호키를 알면 원문을 복호화할 수 있다."
              },
              {
                "id": "C",
                "text": "* 비트: 정보량의 최소 기본 단위."
              },
              {
                "id": "D",
                "text": "그중 격자 기반 완전 동형암호는 수학계에서 답을 찾기 어렵다고 알려진 격자 문제를 응용하여 만들어졌다."
              }
            ],
            "answerId": "D",
            "scoring": {
              "correctDeltaSec": 20,
              "wrongDeltaSec": -20,
              "eliminateWrongChoice": true
            }
          }
        },
        {
          "stepId": "s12",
          "highlight": {
            "paragraphId": "p1",
            "range": {
              "start": 711,
              "end": 758
            }
          },
          "question": {
            "prompt": "하이라이트된 문장의 내용으로 알맞은 것은?",
            "choices": [
              {
                "id": "A",
                "text": "이 방식은 원문 데이터를 비트* 단위로 변환하고 각각의 비트를 개별적으로 암호화한다."
              },
              {
                "id": "B",
                "text": "암호키 p와 임의의 정수를 곱한 수를 원문에 더하면 암호문이 만들어지는데, 이 과정에서 무작위로 오륫값을 추가하여 안전성을 높인다."
              },
              {
                "id": "C",
                "text": "그중 격자 기반 완전 동형암호는 수학계에서 답을 찾기 어렵다고 알려진 격자 문제를 응용하여 만들어졌다."
              },
              {
                "id": "D",
                "text": "이 방식은 하나의 원문을 특정한 정수인 암호키로 나눈 나머지 값을 암호문으로 이용하고, 이 나머지 값에서 원문을 복호화하는 방법이다."
              }
            ],
            "answerId": "A",
            "scoring": {
              "correctDeltaSec": 20,
              "wrongDeltaSec": -20,
              "eliminateWrongChoice": true
            }
          }
        },
        {
          "stepId": "s13",
          "highlight": {
            "paragraphId": "p1",
            "range": {
              "start": 759,
              "end": 832
            }
          },
          "question": {
            "prompt": "하이라이트된 문장의 내용으로 알맞은 것은?",
            "choices": [
              {
                "id": "A",
                "text": "<그림> (원문 연산: A + B \\= A+B)"
              },
              {
                "id": "B",
                "text": "(Ap, Bp는 p로 나눈 나머지, Aq, Bq는 q로 나눈 나머지)"
              },
              {
                "id": "C",
                "text": "그런데 현재 널리 사용되는 공개키 암호화 방식으로 암호화된 데이터는 통계 처리를 위한 연산을 수행하기 위해서 원래 데이터로 복원하는 복호화 과정을 거친 후"
              },
              {
                "id": "D",
                "text": "암호키 p와 임의의 정수를 곱한 수를 원문에 더하면 암호문이 만들어지는데, 이 과정에서 무작위로 오륫값을 추가하여 안전성을 높인다."
              }
            ],
            "answerId": "D",
            "scoring": {
              "correctDeltaSec": 20,
              "wrongDeltaSec": -20,
              "eliminateWrongChoice": true
            }
          }
        },
        {
          "stepId": "s14",
          "highlight": {
            "paragraphId": "p1",
            "range": {
              "start": 833,
              "end": 836
            }
          },
          "question": {
            "prompt": "하이라이트된 접속어가 나타내는 관계로 가장 적절한 것은?",
            "choices": [
              {
                "id": "A",
                "text": "예시"
              },
              {
                "id": "B",
                "text": "첨가"
              },
              {
                "id": "C",
                "text": "대조"
              },
              {
                "id": "D",
                "text": "인과"
              }
            ],
            "answerId": "D",
            "scoring": {
              "correctDeltaSec": 20,
              "wrongDeltaSec": -20,
              "eliminateWrongChoice": true
            }
          }
        },
        {
          "stepId": "s15",
          "highlight": {
            "paragraphId": "p1",
            "range": {
              "start": 833,
              "end": 927
            }
          },
          "question": {
            "prompt": "하이라이트된 문장의 내용으로 알맞은 것은?",
            "choices": [
              {
                "id": "A",
                "text": "완전 동형암호는 암호화에 사용하는 원리에 따라 격자 기반, CRT(Chinese Remainder Theorem) 기반 등으로 나뉜다."
              },
              {
                "id": "B",
                "text": "만약 연산 수행의 결괏값이 암호키와 같거나 암호키보다 크면 한 번 더 암호키로 나누어 나머지 값을 구한다."
              },
              {
                "id": "C",
                "text": "그래서 암호문의 연산을 반복할수록 오륫값이 커지게 되며, 특히 곱셈 연산을 수행할수록 오륫값이 급격하게 커지기 때문에 일정 횟수 이상 수행하면 원문 복호화가"
              },
              {
                "id": "D",
                "text": "그래서 암호화된 데이터를 복호화하지 않고 암호화된 상태로 안전하게 연산을 수행할 수 있는 동형암호가 등장하였다."
              }
            ],
            "answerId": "C",
            "scoring": {
              "correctDeltaSec": 20,
              "wrongDeltaSec": -20,
              "eliminateWrongChoice": true
            }
          }
        },
        {
          "stepId": "s16",
          "highlight": {
            "paragraphId": "p1",
            "range": {
              "start": 928,
              "end": 931
            }
          },
          "question": {
            "prompt": "하이라이트된 접속어가 나타내는 관계로 가장 적절한 것은?",
            "choices": [
              {
                "id": "A",
                "text": "대조"
              },
              {
                "id": "B",
                "text": "인과"
              },
              {
                "id": "C",
                "text": "첨가"
              },
              {
                "id": "D",
                "text": "예시"
              }
            ],
            "answerId": "B",
            "scoring": {
              "correctDeltaSec": 20,
              "wrongDeltaSec": -20,
              "eliminateWrongChoice": true
            }
          }
        },
        {
          "stepId": "s17",
          "highlight": {
            "paragraphId": "p1",
            "range": {
              "start": 928,
              "end": 992
            }
          },
          "question": {
            "prompt": "하이라이트된 문장의 내용으로 알맞은 것은?",
            "choices": [
              {
                "id": "A",
                "text": "이 방식은 원문 데이터를 비트* 단위로 변환하고 각각의 비트를 개별적으로 암호화한다."
              },
              {
                "id": "B",
                "text": "이 방식은 하나의 원문을 특정한 정수인 암호키로 나눈 나머지 값을 암호문으로 이용하고, 이 나머지 값에서 원문을 복호화하는 방법이다."
              },
              {
                "id": "C",
                "text": "따라서 연산을 지속적으로 수행하기 위해서는 오륫값이 한계치에 이른 암호문은 부트스트래핑 과정을 반드시 거쳐야 한다."
              },
              {
                "id": "D",
                "text": "이때 새로운 암호문이 만들어지면서 오륫값이 추가되지만 그 크기가 기존의 누적된 것보다 작아서 적절하게 부트스트래핑 과정을 수행한다면 지속적인 연산이 가능하다."
              }
            ],
            "answerId": "C",
            "scoring": {
              "correctDeltaSec": 20,
              "wrongDeltaSec": -20,
              "eliminateWrongChoice": true
            }
          }
        },
        {
          "stepId": "s18",
          "highlight": {
            "paragraphId": "p1",
            "range": {
              "start": 993,
              "end": 1061
            }
          },
          "question": {
            "prompt": "하이라이트된 문장의 내용으로 알맞은 것은?",
            "choices": [
              {
                "id": "A",
                "text": "그래서 암호화된 데이터를 복호화하지 않고 암호화된 상태로 안전하게 연산을 수행할 수 있는 동형암호가 등장하였다."
              },
              {
                "id": "B",
                "text": "이 방식은 하나의 원문을 특정한 정수인 암호키로 나눈 나머지 값을 암호문으로 이용하고, 이 나머지 값에서 원문을 복호화하는 방법이다."
              },
              {
                "id": "C",
                "text": "일정 횟수의 덧셈과 곱셈 연산을 수행하여 암호문에 오륫값이 누적되면, 다른 암호키로 해당 암호문과 암호키 p를 암호화한다."
              },
              {
                "id": "D",
                "text": "그래서 최근에는 효율성을 개선한 CRT 기반 완전 동형암호가 등장하였다."
              }
            ],
            "answerId": "C",
            "scoring": {
              "correctDeltaSec": 20,
              "wrongDeltaSec": -20,
              "eliminateWrongChoice": true
            }
          }
        },
        {
          "stepId": "s19",
          "highlight": {
            "paragraphId": "p1",
            "range": {
              "start": 1062,
              "end": 1146
            }
          },
          "question": {
            "prompt": "하이라이트된 문장의 내용으로 알맞은 것은?",
            "choices": [
              {
                "id": "A",
                "text": "그런데 현재 널리 사용되는 공개키 암호화 방식으로 암호화된 데이터는 통계 처리를 위한 연산을 수행하기 위해서 원래 데이터로 복원하는 복호화 과정을 거친 후"
              },
              {
                "id": "B",
                "text": "그리고 복호화 회로를 통해 기존의 암호키 p에 의한 이전 암호문을 복호화하면 그동안의 연산 과정에서 누적된 오륫값이 제거된 새로운 암호문이 만들어진다."
              },
              {
                "id": "C",
                "text": "이때 새로운 암호문이 만들어지면서 오륫값이 추가되지만 그 크기가 기존의 누적된 것보다 작아서 적절하게 부트스트래핑 과정을 수행한다면 지속적인 연산이 가능하다."
              },
              {
                "id": "D",
                "text": "(Ap, Bp는 p로 나눈 나머지, Aq, Bq는 q로 나눈 나머지)"
              }
            ],
            "answerId": "B",
            "scoring": {
              "correctDeltaSec": 20,
              "wrongDeltaSec": -20,
              "eliminateWrongChoice": true
            }
          }
        },
        {
          "stepId": "s20",
          "highlight": {
            "paragraphId": "p1",
            "range": {
              "start": 1147,
              "end": 1235
            }
          },
          "question": {
            "prompt": "하이라이트된 문장의 내용으로 알맞은 것은?",
            "choices": [
              {
                "id": "A",
                "text": "이때 새로운 암호문이 만들어지면서 오륫값이 추가되지만 그 크기가 기존의 누적된 것보다 작아서 적절하게 부트스트래핑 과정을 수행한다면 지속적인 연산이 가능하다."
              },
              {
                "id": "B",
                "text": "또한 CRT 방식은 원문보다 작은 나머지 값으로 연산을 수행하기 때문에 격자 기반의 방식에 비해 연산 값이 상대적으로 작아 연산 속도가 빠르고, 격자 기반의"
              },
              {
                "id": "C",
                "text": "(암호 연산: Ap + Bp \\= (A+B)p / Aq + Bq \\= (A+B)q)"
              },
              {
                "id": "D",
                "text": "이때 연산의 횟수에 제한 없이 특정한 한 종류의 연산에만 동형성을 갖는 암호를 부분 동형암호, 연산의 종류와 관계없이 특정 횟수까지만 동형성을 갖는 암호를"
              }
            ],
            "answerId": "A",
            "scoring": {
              "correctDeltaSec": 20,
              "wrongDeltaSec": -20,
              "eliminateWrongChoice": true
            }
          }
        },
        {
          "stepId": "s21",
          "highlight": {
            "paragraphId": "p1",
            "range": {
              "start": 1236,
              "end": 1324
            }
          },
          "question": {
            "prompt": "하이라이트된 문장의 내용으로 알맞은 것은?",
            "choices": [
              {
                "id": "A",
                "text": "<그림> (원문 연산: A + B \\= A+B)"
              },
              {
                "id": "B",
                "text": "1비트는 이진수 체계(0, 1)의 한 자리."
              },
              {
                "id": "C",
                "text": "이 방식은 원문을 비트 단위로 변환하여 각 비트별로 암호화하기 때문에 원문에 비해 암호문의 값이 10~100배가량 커져서 데이터의 저장 공간이 많이 필요하다."
              },
              {
                "id": "D",
                "text": "그중 격자 기반 완전 동형암호는 수학계에서 답을 찾기 어렵다고 알려진 격자 문제를 응용하여 만들어졌다."
              }
            ],
            "answerId": "C",
            "scoring": {
              "correctDeltaSec": 20,
              "wrongDeltaSec": -20,
              "eliminateWrongChoice": true
            }
          }
        },
        {
          "stepId": "s22",
          "highlight": {
            "paragraphId": "p1",
            "range": {
              "start": 1325,
              "end": 1381
            }
          },
          "question": {
            "prompt": "하이라이트된 문장의 내용으로 알맞은 것은?",
            "choices": [
              {
                "id": "A",
                "text": "일정 횟수의 덧셈과 곱셈 연산을 수행하여 암호문에 오륫값이 누적되면, 다른 암호키로 해당 암호문과 암호키 p를 암호화한다."
              },
              {
                "id": "B",
                "text": "그리고 개별 비트 단위로 암호문의 연산과 부트스트래핑 과정을 거쳐야 하기 때문에 연산 속도가 느리다."
              },
              {
                "id": "C",
                "text": "(Ap, Bp는 p로 나눈 나머지, Aq, Bq는 q로 나눈 나머지)"
              },
              {
                "id": "D",
                "text": "그리고 <그림>처럼 각 원문을 동일한 암호키로 나눈 나머지 값인 Ap와 Bp, Aq와 Bq끼리 서로 덧셈 연산을 수행한다."
              }
            ],
            "answerId": "B",
            "scoring": {
              "correctDeltaSec": 20,
              "wrongDeltaSec": -20,
              "eliminateWrongChoice": true
            }
          }
        },
        {
          "stepId": "s23",
          "highlight": {
            "paragraphId": "p1",
            "range": {
              "start": 1382,
              "end": 1385
            }
          },
          "question": {
            "prompt": "하이라이트된 접속어가 나타내는 관계로 가장 적절한 것은?",
            "choices": [
              {
                "id": "A",
                "text": "대조"
              },
              {
                "id": "B",
                "text": "인과"
              },
              {
                "id": "C",
                "text": "첨가"
              },
              {
                "id": "D",
                "text": "예시"
              }
            ],
            "answerId": "B",
            "scoring": {
              "correctDeltaSec": 20,
              "wrongDeltaSec": -20,
              "eliminateWrongChoice": true
            }
          }
        },
        {
          "stepId": "s24",
          "highlight": {
            "paragraphId": "p1",
            "range": {
              "start": 1382,
              "end": 1422
            }
          },
          "question": {
            "prompt": "하이라이트된 문장의 내용으로 알맞은 것은?",
            "choices": [
              {
                "id": "A",
                "text": "하지만 이 과정에서 비밀키나 민감한 개인정보가 유출되는 일이 생길 수 있다."
              },
              {
                "id": "B",
                "text": "그래서 최근에는 효율성을 개선한 CRT 기반 완전 동형암호가 등장하였다."
              },
              {
                "id": "C",
                "text": "그러면 연산 수행의 결괏값인 Ap+Bp, Aq+Bq가 원문 A와 B를 직접 덧셈 연산한 결괏값을 암호키 p와 q로 나눈 나머지 값인 (A+B)p, (A+B)q와"
              },
              {
                "id": "D",
                "text": "이 방식은 하나의 원문을 특정한 정수인 암호키로 나눈 나머지 값을 암호문으로 이용하고, 이 나머지 값에서 원문을 복호화하는 방법이다."
              }
            ],
            "answerId": "B",
            "scoring": {
              "correctDeltaSec": 20,
              "wrongDeltaSec": -20,
              "eliminateWrongChoice": true
            }
          }
        },
        {
          "stepId": "s25",
          "highlight": {
            "paragraphId": "p1",
            "range": {
              "start": 1423,
              "end": 1497
            }
          },
          "question": {
            "prompt": "하이라이트된 문장의 내용으로 알맞은 것은?",
            "choices": [
              {
                "id": "A",
                "text": "일정 횟수의 덧셈과 곱셈 연산을 수행하여 암호문에 오륫값이 누적되면, 다른 암호키로 해당 암호문과 암호키 p를 암호화한다."
              },
              {
                "id": "B",
                "text": "이 방식은 원문을 비트 단위로 변환하여 각 비트별로 암호화하기 때문에 원문에 비해 암호문의 값이 10~100배가량 커져서 데이터의 저장 공간이 많이 필요하다."
              },
              {
                "id": "C",
                "text": "1비트는 이진수 체계(0, 1)의 한 자리."
              },
              {
                "id": "D",
                "text": "이 방식은 하나의 원문을 특정한 정수인 암호키로 나눈 나머지 값을 암호문으로 이용하고, 이 나머지 값에서 원문을 복호화하는 방법이다."
              }
            ],
            "answerId": "D",
            "scoring": {
              "correctDeltaSec": 20,
              "wrongDeltaSec": -20,
              "eliminateWrongChoice": true
            }
          }
        },
        {
          "stepId": "s26",
          "highlight": {
            "paragraphId": "p1",
            "range": {
              "start": 1498,
              "end": 1554
            }
          },
          "question": {
            "prompt": "하이라이트된 문장의 내용으로 알맞은 것은?",
            "choices": [
              {
                "id": "A",
                "text": "이때 암호키의 개수는 임의로 설정할 수 있으며 각각의 원문마다 암호키의 개수만큼 암호문이 만들어진다."
              },
              {
                "id": "B",
                "text": "그리고 복호화 회로를 통해 기존의 암호키 p에 의한 이전 암호문을 복호화하면 그동안의 연산 과정에서 누적된 오륫값이 제거된 새로운 암호문이 만들어진다."
              },
              {
                "id": "C",
                "text": "따라서 연산을 지속적으로 수행하기 위해서는 오륫값이 한계치에 이른 암호문은 부트스트래핑 과정을 반드시 거쳐야 한다."
              },
              {
                "id": "D",
                "text": "그중 격자 기반 완전 동형암호는 수학계에서 답을 찾기 어렵다고 알려진 격자 문제를 응용하여 만들어졌다."
              }
            ],
            "answerId": "A",
            "scoring": {
              "correctDeltaSec": 20,
              "wrongDeltaSec": -20,
              "eliminateWrongChoice": true
            }
          }
        },
        {
          "stepId": "s27",
          "highlight": {
            "paragraphId": "p1",
            "range": {
              "start": 1555,
              "end": 1614
            }
          },
          "question": {
            "prompt": "하이라이트된 문장의 내용으로 알맞은 것은?",
            "choices": [
              {
                "id": "A",
                "text": "이때 연산의 횟수에 제한 없이 특정한 한 종류의 연산에만 동형성을 갖는 암호를 부분 동형암호, 연산의 종류와 관계없이 특정 횟수까지만 동형성을 갖는 암호를"
              },
              {
                "id": "B",
                "text": "암호키가 두 개일 때 정수로 된 원문 A와 B를 덧셈 연산한 결과가 동형성을 갖는 원리를 간단히 알아보자."
              },
              {
                "id": "C",
                "text": "동형암호는 동형성을 기반으로 하는데, 동형성이란 데이터를 암호화한 상태에서 특정 연산을 수행했을 때 나오는 결과가 암호화하지 않은 상태에서 같은 연산을 수행하고"
              },
              {
                "id": "D",
                "text": "그리고 복호화 회로를 통해 기존의 암호키 p에 의한 이전 암호문을 복호화하면 그동안의 연산 과정에서 누적된 오륫값이 제거된 새로운 암호문이 만들어진다."
              }
            ],
            "answerId": "B",
            "scoring": {
              "correctDeltaSec": 20,
              "wrongDeltaSec": -20,
              "eliminateWrongChoice": true
            }
          }
        },
        {
          "stepId": "s28",
          "highlight": {
            "paragraphId": "p1",
            "range": {
              "start": 1615,
              "end": 1730
            }
          },
          "question": {
            "prompt": "하이라이트된 문장의 내용으로 알맞은 것은?",
            "choices": [
              {
                "id": "A",
                "text": "그래서 최근에는 효율성을 개선한 CRT 기반 완전 동형암호가 등장하였다."
              },
              {
                "id": "B",
                "text": "이 방식은 원문을 비트 단위로 변환하여 각 비트별로 암호화하기 때문에 원문에 비해 암호문의 값이 10~100배가량 커져서 데이터의 저장 공간이 많이 필요하다."
              },
              {
                "id": "C",
                "text": "그리고 복호화 회로를 통해 기존의 암호키 p에 의한 이전 암호문을 복호화하면 그동안의 연산 과정에서 누적된 오륫값이 제거된 새로운 암호문이 만들어진다."
              },
              {
                "id": "D",
                "text": "우선 서로소*인 임의의 정수 p와 q를 암호키로 정하고 정수로 된 원문 A와 B를 각각의 암호키로 나눈 나머지 값을 구하면 Ap, Aq와 Bp, Bq가 되는데"
              }
            ],
            "answerId": "D",
            "scoring": {
              "correctDeltaSec": 20,
              "wrongDeltaSec": -20,
              "eliminateWrongChoice": true
            }
          }
        },
        {
          "stepId": "s29",
          "highlight": {
            "paragraphId": "p1",
            "range": {
              "start": 1731,
              "end": 1799
            }
          },
          "question": {
            "prompt": "하이라이트된 문장의 내용으로 알맞은 것은?",
            "choices": [
              {
                "id": "A",
                "text": "그리고 <그림>처럼 각 원문을 동일한 암호키로 나눈 나머지 값인 Ap와 Bp, Aq와 Bq끼리 서로 덧셈 연산을 수행한다."
              },
              {
                "id": "B",
                "text": "1비트는 이진수 체계(0, 1)의 한 자리."
              },
              {
                "id": "C",
                "text": "그중 격자 기반 완전 동형암호는 수학계에서 답을 찾기 어렵다고 알려진 격자 문제를 응용하여 만들어졌다."
              },
              {
                "id": "D",
                "text": "이 방식은 원문을 비트 단위로 변환하여 각 비트별로 암호화하기 때문에 원문에 비해 암호문의 값이 10~100배가량 커져서 데이터의 저장 공간이 많이 필요하다."
              }
            ],
            "answerId": "A",
            "scoring": {
              "correctDeltaSec": 20,
              "wrongDeltaSec": -20,
              "eliminateWrongChoice": true
            }
          }
        },
        {
          "stepId": "s30",
          "highlight": {
            "paragraphId": "p1",
            "range": {
              "start": 1800,
              "end": 1859
            }
          },
          "question": {
            "prompt": "하이라이트된 문장의 내용으로 알맞은 것은?",
            "choices": [
              {
                "id": "A",
                "text": "(암호 연산: Ap + Bp \\= (A+B)p / Aq + Bq \\= (A+B)q)"
              },
              {
                "id": "B",
                "text": "만약 연산 수행의 결괏값이 암호키와 같거나 암호키보다 크면 한 번 더 암호키로 나누어 나머지 값을 구한다."
              },
              {
                "id": "C",
                "text": "* 비트: 정보량의 최소 기본 단위."
              },
              {
                "id": "D",
                "text": "이 방식은 원문 데이터를 비트* 단위로 변환하고 각각의 비트를 개별적으로 암호화한다."
              }
            ],
            "answerId": "B",
            "scoring": {
              "correctDeltaSec": 20,
              "wrongDeltaSec": -20,
              "eliminateWrongChoice": true
            }
          }
        },
        {
          "stepId": "s31",
          "highlight": {
            "paragraphId": "p1",
            "range": {
              "start": 1860,
              "end": 1953
            }
          },
          "question": {
            "prompt": "하이라이트된 문장의 내용으로 알맞은 것은?",
            "choices": [
              {
                "id": "A",
                "text": "그러면 연산 수행의 결괏값인 Ap+Bp, Aq+Bq가 원문 A와 B를 직접 덧셈 연산한 결괏값을 암호키 p와 q로 나눈 나머지 값인 (A+B)p, (A+B)q와"
              },
              {
                "id": "B",
                "text": "(암호 연산: Ap + Bp \\= (A+B)p / Aq + Bq \\= (A+B)q)"
              },
              {
                "id": "C",
                "text": "이 방식 또한 안전성을 위해서 암호키의 개수를 늘려 계산이 복잡하고 무작위로 오륫값을 추가하기 때문에 부트스트래핑 과정이 필요하다."
              },
              {
                "id": "D",
                "text": "1비트는 이진수 체계(0, 1)의 한 자리."
              }
            ],
            "answerId": "A",
            "scoring": {
              "correctDeltaSec": 20,
              "wrongDeltaSec": -20,
              "eliminateWrongChoice": true
            }
          }
        },
        {
          "stepId": "s32",
          "highlight": {
            "paragraphId": "p1",
            "range": {
              "start": 1954,
              "end": 2008
            }
          },
          "question": {
            "prompt": "하이라이트된 문장의 내용으로 알맞은 것은?",
            "choices": [
              {
                "id": "A",
                "text": "그리고 복호화 회로를 통해 기존의 암호키 p에 의한 이전 암호문을 복호화하면 그동안의 연산 과정에서 누적된 오륫값이 제거된 새로운 암호문이 만들어진다."
              },
              {
                "id": "B",
                "text": "그리고 원문을 각 암호키로 나누었을 때의 나머지 값과 각 암호키를 알면 원문을 복호화할 수 있다."
              },
              {
                "id": "C",
                "text": "* 서로소: 여러 개의 수 사이에 1 이외의 공약수가 없음을 이르는 말."
              },
              {
                "id": "D",
                "text": "하지만 데이터를 정수 단위로 암호화하기 때문에 비트 단위로 암호화하는 격자 기반의 방식보다 더 많은 데이터를 저장할 수 있다."
              }
            ],
            "answerId": "B",
            "scoring": {
              "correctDeltaSec": 20,
              "wrongDeltaSec": -20,
              "eliminateWrongChoice": true
            }
          }
        },
        {
          "stepId": "s33",
          "highlight": {
            "paragraphId": "p1",
            "range": {
              "start": 0,
              "end": 2008
            }
          },
          "question": {
            "prompt": "이 문단의 중심 내용으로 가장 적절한 것은?",
            "choices": [
              {
                "id": "A",
                "text": "그리고 <그림>처럼 각 원문을 동일한 암호키로 나눈 나머지 값인 Ap와 Bp, Aq와 Bq끼리 서로 덧셈 연산을 수행한다."
              },
              {
                "id": "B",
                "text": "인터넷의 발달로 데이터 저장 및 분석 과정이 인터넷상에서 이루어지고 있으며 그에 따라 개인정보와 같은 민감한 데이터는 암호화되어 인터넷 서버에 저장된다."
              },
              {
                "id": "C",
                "text": "그리고 원문을 각 암호키로 나누었을 때의 나머지 값과 각 암호키를 알면 원문을 복호화할 수 있다."
              },
              {
                "id": "D",
                "text": "(암호 연산: Ap + Bp \\= (A+B)p / Aq + Bq \\= (A+B)q)"
              }
            ],
            "answerId": "B",
            "scoring": {
              "correctDeltaSec": 20,
              "wrongDeltaSec": -20,
              "eliminateWrongChoice": true
            }
          }
        },
        {
          "stepId": "s34",
          "highlight": {
            "paragraphId": "p2",
            "range": {
              "start": 0,
              "end": 26
            }
          },
          "question": {
            "prompt": "하이라이트된 문장의 내용으로 알맞은 것은?",
            "choices": [
              {
                "id": "A",
                "text": "* 서로소: 여러 개의 수 사이에 1 이외의 공약수가 없음을 이르는 말."
              },
              {
                "id": "B",
                "text": "그리고 개별 비트 단위로 암호문의 연산과 부트스트래핑 과정을 거쳐야 하기 때문에 연산 속도가 느리다."
              },
              {
                "id": "C",
                "text": "<그림> (원문 연산: A + B \\= A+B)"
              },
              {
                "id": "D",
                "text": "이 방식 또한 안전성을 위해서 암호키의 개수를 늘려 계산이 복잡하고 무작위로 오륫값을 추가하기 때문에 부트스트래핑 과정이 필요하다."
              }
            ],
            "answerId": "C",
            "scoring": {
              "correctDeltaSec": 20,
              "wrongDeltaSec": -20,
              "eliminateWrongChoice": true
            }
          }
        },
        {
          "stepId": "s35",
          "highlight": {
            "paragraphId": "p2",
            "range": {
              "start": 27,
              "end": 73
            }
          },
          "question": {
            "prompt": "하이라이트된 문장의 내용으로 알맞은 것은?",
            "choices": [
              {
                "id": "A",
                "text": "이 방식은 하나의 원문을 특정한 정수인 암호키로 나눈 나머지 값을 암호문으로 이용하고, 이 나머지 값에서 원문을 복호화하는 방법이다."
              },
              {
                "id": "B",
                "text": "(암호 연산: Ap + Bp \\= (A+B)p / Aq + Bq \\= (A+B)q)"
              },
              {
                "id": "C",
                "text": "<그림> (원문 연산: A + B \\= A+B)"
              },
              {
                "id": "D",
                "text": "암호키 p와 임의의 정수를 곱한 수를 원문에 더하면 암호문이 만들어지는데, 이 과정에서 무작위로 오륫값을 추가하여 안전성을 높인다."
              }
            ],
            "answerId": "B",
            "scoring": {
              "correctDeltaSec": 20,
              "wrongDeltaSec": -20,
              "eliminateWrongChoice": true
            }
          }
        },
        {
          "stepId": "s36",
          "highlight": {
            "paragraphId": "p2",
            "range": {
              "start": 74,
              "end": 112
            }
          },
          "question": {
            "prompt": "하이라이트된 문장의 내용으로 알맞은 것은?",
            "choices": [
              {
                "id": "A",
                "text": "그래서 최근에는 효율성을 개선한 CRT 기반 완전 동형암호가 등장하였다."
              },
              {
                "id": "B",
                "text": "(Ap, Bp는 p로 나눈 나머지, Aq, Bq는 q로 나눈 나머지)"
              },
              {
                "id": "C",
                "text": "만약 연산 수행의 결괏값이 암호키와 같거나 암호키보다 크면 한 번 더 암호키로 나누어 나머지 값을 구한다."
              },
              {
                "id": "D",
                "text": "그런데 현재 널리 사용되는 공개키 암호화 방식으로 암호화된 데이터는 통계 처리를 위한 연산을 수행하기 위해서 원래 데이터로 복원하는 복호화 과정을 거친 후"
              }
            ],
            "answerId": "B",
            "scoring": {
              "correctDeltaSec": 20,
              "wrongDeltaSec": -20,
              "eliminateWrongChoice": true
            }
          }
        },
        {
          "stepId": "s37",
          "highlight": {
            "paragraphId": "p2",
            "range": {
              "start": 0,
              "end": 112
            }
          },
          "question": {
            "prompt": "이 문단의 중심 내용으로 가장 적절한 것은?",
            "choices": [
              {
                "id": "A",
                "text": "<그림> (원문 연산: A + B \\= A+B)"
              },
              {
                "id": "B",
                "text": "완전 동형암호는 암호화에 사용하는 원리에 따라 격자 기반, CRT(Chinese Remainder Theorem) 기반 등으로 나뉜다."
              },
              {
                "id": "C",
                "text": "이때 새로운 암호문이 만들어지면서 오륫값이 추가되지만 그 크기가 기존의 누적된 것보다 작아서 적절하게 부트스트래핑 과정을 수행한다면 지속적인 연산이 가능하다."
              },
              {
                "id": "D",
                "text": "또한 CRT 방식은 원문보다 작은 나머지 값으로 연산을 수행하기 때문에 격자 기반의 방식에 비해 연산 값이 상대적으로 작아 연산 속도가 빠르고, 격자 기반의"
              }
            ],
            "answerId": "A",
            "scoring": {
              "correctDeltaSec": 20,
              "wrongDeltaSec": -20,
              "eliminateWrongChoice": true
            }
          }
        },
        {
          "stepId": "s38",
          "highlight": {
            "paragraphId": "p3",
            "range": {
              "start": 8,
              "end": 12
            }
          },
          "question": {
            "prompt": "하이라이트된 말의 문장 성분으로 가장 알맞은 것은?",
            "choices": [
              {
                "id": "A",
                "text": "주어"
              },
              {
                "id": "B",
                "text": "목적어"
              },
              {
                "id": "C",
                "text": "서술어"
              },
              {
                "id": "D",
                "text": "부사어"
              }
            ],
            "answerId": "B",
            "scoring": {
              "correctDeltaSec": 20,
              "wrongDeltaSec": -20,
              "eliminateWrongChoice": true
            }
          }
        },
        {
          "stepId": "s39",
          "highlight": {
            "paragraphId": "p3",
            "range": {
              "start": 5,
              "end": 7
            }
          },
          "question": {
            "prompt": "하이라이트된 접속어가 나타내는 관계로 가장 적절한 것은?",
            "choices": [
              {
                "id": "A",
                "text": "대조"
              },
              {
                "id": "B",
                "text": "첨가"
              },
              {
                "id": "C",
                "text": "인과"
              },
              {
                "id": "D",
                "text": "예시"
              }
            ],
            "answerId": "B",
            "scoring": {
              "correctDeltaSec": 20,
              "wrongDeltaSec": -20,
              "eliminateWrongChoice": true
            }
          }
        },
        {
          "stepId": "s40",
          "highlight": {
            "paragraphId": "p3",
            "range": {
              "start": 0,
              "end": 73
            }
          },
          "question": {
            "prompt": "하이라이트된 문장의 내용으로 알맞은 것은?",
            "choices": [
              {
                "id": "A",
                "text": "그리고 개별 비트 단위로 암호문의 연산과 부트스트래핑 과정을 거쳐야 하기 때문에 연산 속도가 느리다."
              },
              {
                "id": "B",
                "text": "이 방식은 원문을 비트 단위로 변환하여 각 비트별로 암호화하기 때문에 원문에 비해 암호문의 값이 10~100배가량 커져서 데이터의 저장 공간이 많이 필요하다."
              },
              {
                "id": "C",
                "text": "이 방식 또한 안전성을 위해서 암호키의 개수를 늘려 계산이 복잡하고 무작위로 오륫값을 추가하기 때문에 부트스트래핑 과정이 필요하다."
              },
              {
                "id": "D",
                "text": "(Ap, Bp는 p로 나눈 나머지, Aq, Bq는 q로 나눈 나머지)"
              }
            ],
            "answerId": "C",
            "scoring": {
              "correctDeltaSec": 20,
              "wrongDeltaSec": -20,
              "eliminateWrongChoice": true
            }
          }
        },
        {
          "stepId": "s41",
          "highlight": {
            "paragraphId": "p3",
            "range": {
              "start": 74,
              "end": 77
            }
          },
          "question": {
            "prompt": "하이라이트된 접속어가 나타내는 관계로 가장 적절한 것은?",
            "choices": [
              {
                "id": "A",
                "text": "인과"
              },
              {
                "id": "B",
                "text": "예시"
              },
              {
                "id": "C",
                "text": "첨가"
              },
              {
                "id": "D",
                "text": "대조"
              }
            ],
            "answerId": "D",
            "scoring": {
              "correctDeltaSec": 20,
              "wrongDeltaSec": -20,
              "eliminateWrongChoice": true
            }
          }
        },
        {
          "stepId": "s42",
          "highlight": {
            "paragraphId": "p3",
            "range": {
              "start": 74,
              "end": 144
            }
          },
          "question": {
            "prompt": "하이라이트된 문장의 내용으로 알맞은 것은?",
            "choices": [
              {
                "id": "A",
                "text": "완전 동형암호는 암호화에 사용하는 원리에 따라 격자 기반, CRT(Chinese Remainder Theorem) 기반 등으로 나뉜다."
              },
              {
                "id": "B",
                "text": "하지만 데이터를 정수 단위로 암호화하기 때문에 비트 단위로 암호화하는 격자 기반의 방식보다 더 많은 데이터를 저장할 수 있다."
              },
              {
                "id": "C",
                "text": "그런데 현재 널리 사용되는 공개키 암호화 방식으로 암호화된 데이터는 통계 처리를 위한 연산을 수행하기 위해서 원래 데이터로 복원하는 복호화 과정을 거친 후"
              },
              {
                "id": "D",
                "text": "그러면 연산 수행의 결괏값인 Ap+Bp, Aq+Bq가 원문 A와 B를 직접 덧셈 연산한 결괏값을 암호키 p와 q로 나눈 나머지 값인 (A+B)p, (A+B)q와"
              }
            ],
            "answerId": "B",
            "scoring": {
              "correctDeltaSec": 20,
              "wrongDeltaSec": -20,
              "eliminateWrongChoice": true
            }
          }
        },
        {
          "stepId": "s43",
          "highlight": {
            "paragraphId": "p3",
            "range": {
              "start": 145,
              "end": 147
            }
          },
          "question": {
            "prompt": "하이라이트된 접속어가 나타내는 관계로 가장 적절한 것은?",
            "choices": [
              {
                "id": "A",
                "text": "인과"
              },
              {
                "id": "B",
                "text": "예시"
              },
              {
                "id": "C",
                "text": "첨가"
              },
              {
                "id": "D",
                "text": "대조"
              }
            ],
            "answerId": "C",
            "scoring": {
              "correctDeltaSec": 20,
              "wrongDeltaSec": -20,
              "eliminateWrongChoice": true
            }
          }
        },
        {
          "stepId": "s44",
          "highlight": {
            "paragraphId": "p3",
            "range": {
              "start": 145,
              "end": 259
            }
          },
          "question": {
            "prompt": "하이라이트된 문장의 내용으로 알맞은 것은?",
            "choices": [
              {
                "id": "A",
                "text": "따라서 연산을 지속적으로 수행하기 위해서는 오륫값이 한계치에 이른 암호문은 부트스트래핑 과정을 반드시 거쳐야 한다."
              },
              {
                "id": "B",
                "text": "이 방식은 원문 데이터를 비트* 단위로 변환하고 각각의 비트를 개별적으로 암호화한다."
              },
              {
                "id": "C",
                "text": "또한 CRT 방식은 원문보다 작은 나머지 값으로 연산을 수행하기 때문에 격자 기반의 방식에 비해 연산 값이 상대적으로 작아 연산 속도가 빠르고, 격자 기반의"
              },
              {
                "id": "D",
                "text": "그리고 원문을 각 암호키로 나누었을 때의 나머지 값과 각 암호키를 알면 원문을 복호화할 수 있다."
              }
            ],
            "answerId": "C",
            "scoring": {
              "correctDeltaSec": 20,
              "wrongDeltaSec": -20,
              "eliminateWrongChoice": true
            }
          }
        },
        {
          "stepId": "s45",
          "highlight": {
            "paragraphId": "p3",
            "range": {
              "start": 0,
              "end": 259
            }
          },
          "question": {
            "prompt": "이 문단의 중심 내용으로 가장 적절한 것은?",
            "choices": [
              {
                "id": "A",
                "text": "* 비트: 정보량의 최소 기본 단위."
              },
              {
                "id": "B",
                "text": "* 서로소: 여러 개의 수 사이에 1 이외의 공약수가 없음을 이르는 말."
              },
              {
                "id": "C",
                "text": "이 방식은 원문을 비트 단위로 변환하여 각 비트별로 암호화하기 때문에 원문에 비해 암호문의 값이 10~100배가량 커져서 데이터의 저장 공간이 많이 필요하다."
              },
              {
                "id": "D",
                "text": "이 방식 또한 안전성을 위해서 암호키의 개수를 늘려 계산이 복잡하고 무작위로 오륫값을 추가하기 때문에 부트스트래핑 과정이 필요하다."
              }
            ],
            "answerId": "D",
            "scoring": {
              "correctDeltaSec": 20,
              "wrongDeltaSec": -20,
              "eliminateWrongChoice": true
            }
          }
        },
        {
          "stepId": "s46",
          "highlight": {
            "paragraphId": "p4",
            "range": {
              "start": 0,
              "end": 20
            }
          },
          "question": {
            "prompt": "하이라이트된 문장의 내용으로 알맞은 것은?",
            "choices": [
              {
                "id": "A",
                "text": "* 비트: 정보량의 최소 기본 단위."
              },
              {
                "id": "B",
                "text": "(암호 연산: Ap + Bp \\= (A+B)p / Aq + Bq \\= (A+B)q)"
              },
              {
                "id": "C",
                "text": "그리고 복호화 회로를 통해 기존의 암호키 p에 의한 이전 암호문을 복호화하면 그동안의 연산 과정에서 누적된 오륫값이 제거된 새로운 암호문이 만들어진다."
              },
              {
                "id": "D",
                "text": "그리고 <그림>처럼 각 원문을 동일한 암호키로 나눈 나머지 값인 Ap와 Bp, Aq와 Bq끼리 서로 덧셈 연산을 수행한다."
              }
            ],
            "answerId": "A",
            "scoring": {
              "correctDeltaSec": 20,
              "wrongDeltaSec": -20,
              "eliminateWrongChoice": true
            }
          }
        },
        {
          "stepId": "s47",
          "highlight": {
            "paragraphId": "p4",
            "range": {
              "start": 22,
              "end": 25
            }
          },
          "question": {
            "prompt": "하이라이트된 말의 문장 성분으로 가장 알맞은 것은?",
            "choices": [
              {
                "id": "A",
                "text": "목적어"
              },
              {
                "id": "B",
                "text": "서술어"
              },
              {
                "id": "C",
                "text": "주어"
              },
              {
                "id": "D",
                "text": "부사어"
              }
            ],
            "answerId": "C",
            "scoring": {
              "correctDeltaSec": 20,
              "wrongDeltaSec": -20,
              "eliminateWrongChoice": true
            }
          }
        },
        {
          "stepId": "s48",
          "highlight": {
            "paragraphId": "p4",
            "range": {
              "start": 21,
              "end": 45
            }
          },
          "question": {
            "prompt": "하이라이트된 문장의 내용으로 알맞은 것은?",
            "choices": [
              {
                "id": "A",
                "text": "1비트는 이진수 체계(0, 1)의 한 자리."
              },
              {
                "id": "B",
                "text": "또한 CRT 방식은 원문보다 작은 나머지 값으로 연산을 수행하기 때문에 격자 기반의 방식에 비해 연산 값이 상대적으로 작아 연산 속도가 빠르고, 격자 기반의"
              },
              {
                "id": "C",
                "text": "동형암호는 동형성을 기반으로 하는데, 동형성이란 데이터를 암호화한 상태에서 특정 연산을 수행했을 때 나오는 결과가 암호화하지 않은 상태에서 같은 연산을 수행하고"
              },
              {
                "id": "D",
                "text": "그래서 암호문의 연산을 반복할수록 오륫값이 커지게 되며, 특히 곱셈 연산을 수행할수록 오륫값이 급격하게 커지기 때문에 일정 횟수 이상 수행하면 원문 복호화가"
              }
            ],
            "answerId": "A",
            "scoring": {
              "correctDeltaSec": 20,
              "wrongDeltaSec": -20,
              "eliminateWrongChoice": true
            }
          }
        },
        {
          "stepId": "s49",
          "highlight": {
            "paragraphId": "p4",
            "range": {
              "start": 46,
              "end": 86
            }
          },
          "question": {
            "prompt": "하이라이트된 문장의 내용으로 알맞은 것은?",
            "choices": [
              {
                "id": "A",
                "text": "이 방식은 원문 데이터를 비트* 단위로 변환하고 각각의 비트를 개별적으로 암호화한다."
              },
              {
                "id": "B",
                "text": "완전 동형암호는 암호화에 사용하는 원리에 따라 격자 기반, CRT(Chinese Remainder Theorem) 기반 등으로 나뉜다."
              },
              {
                "id": "C",
                "text": "그래서 최근에는 효율성을 개선한 CRT 기반 완전 동형암호가 등장하였다."
              },
              {
                "id": "D",
                "text": "* 서로소: 여러 개의 수 사이에 1 이외의 공약수가 없음을 이르는 말."
              }
            ],
            "answerId": "D",
            "scoring": {
              "correctDeltaSec": 20,
              "wrongDeltaSec": -20,
              "eliminateWrongChoice": true
            }
          }
        },
        {
          "stepId": "s50",
          "highlight": {
            "paragraphId": "p4",
            "range": {
              "start": 0,
              "end": 86
            }
          },
          "question": {
            "prompt": "이 문단의 중심 내용으로 가장 적절한 것은?",
            "choices": [
              {
                "id": "A",
                "text": "그래서 암호문의 연산을 반복할수록 오륫값이 커지게 되며, 특히 곱셈 연산을 수행할수록 오륫값이 급격하게 커지기 때문에 일정 횟수 이상 수행하면 원문 복호화가"
              },
              {
                "id": "B",
                "text": "1비트는 이진수 체계(0, 1)의 한 자리."
              },
              {
                "id": "C",
                "text": "이 방식은 원문 데이터를 비트* 단위로 변환하고 각각의 비트를 개별적으로 암호화한다."
              },
              {
                "id": "D",
                "text": "* 비트: 정보량의 최소 기본 단위."
              }
            ],
            "answerId": "D",
            "scoring": {
              "correctDeltaSec": 20,
              "wrongDeltaSec": -20,
              "eliminateWrongChoice": true
            }
          }
        }
      ]
    },
    "recall": {
      "cards": [
        {
          "id": "c1",
          "text": "인터넷의 발달로 데이터 저장 및 분석 과정이 인터넷상에서 이루어지고 있으며 그에 따라 개인정보와 같은 민감한 데이터는 암호화되어 인터넷 서버에 저장된다. 그런데 현재 널리 사용되는 공개키 암호화 방식으로 암호화된 데이터는 통계 처리를 위한 연산을 수행하기 위해서 원래 데이터로 복원하는 복호화 과정을 거친 후 연산을 수행하고 그 결과를 다시 암호화해야 한다. 하지만 이 과정에서 비밀키나 민감한 개인정보가 유출되는 일이 생길 수 있다. 그래서 암호화된 데이터를 복호화하지 않고 암호화된 상태로 안전하게 연산을 수행할 수 있는 동형암호가 등장하였다.\n동형암호는 동형성을 기반으로 하는데, 동형성이란 데이터를 암호화한 상태에서 특정 연산을 수행했을 때 나오는 결과가 암호화하지 않은 상태에서 같은 연산을 수행하고 암호화를 한 결과와 같은 것을 말한다. 이때 연산의 횟수에 제한 없이 특정한 한 종류의 연산에만 동형성을 갖는 암호를 부분 동형암호, 연산의 종류와 관계없이 특정 횟수까지만"
        },
        {
          "id": "c2",
          "text": "동형성을 갖는 암호를 제한적 동형암호라고 하며, 횟수에 제한 없이 컴퓨터의 주된 연산인 덧셈, 곱셈에 동형성을 갖는 암호를 완전 동형암호라고 한다.\n완전 동형암호는 암호화에 사용하는 원리에 따라 격자 기반, CRT(Chinese Remainder Theorem) 기반 등으로 나뉜다. 그중 격자 기반 완전 동형암호는 수학계에서 답을 찾기 어렵다고 알려진 격자 문제를 응용하여 만들어졌다. 이 방식은 원문 데이터를 비트* 단위로 변환하고 각각의 비트를 개별적으로 암호화한다. 암호키 p와 임의의 정수를 곱한 수를 원문에 더하면 암호문이 만들어지는데, 이 과정에서 무작위로 오륫값을 추가하여 안전성을 높인다. 그래서 암호문의 연산을 반복할수록 오륫값이 커지게 되며, 특히 곱셈 연산을 수행할수록 오륫값이 급격하게 커지기 때문에 일정 횟수 이상 수행하면 원문 복호화가 불가능하다.\n따라서 연산을 지속적으로 수행하기 위해서는 오륫값이 한계치에 이른 암호문은 부트스트래핑 과정을 반드시 거"
        },
        {
          "id": "c3",
          "text": "쳐야 한다. 일정 횟수의 덧셈과 곱셈 연산을 수행하여 암호문에 오륫값이 누적되면, 다른 암호키로 해당 암호문과 암호키 p를 암호화한다. 그리고 복호화 회로를 통해 기존의 암호키 p에 의한 이전 암호문을 복호화하면 그동안의 연산 과정에서 누적된 오륫값이 제거된 새로운 암호문이 만들어진다. 이때 새로운 암호문이 만들어지면서 오륫값이 추가되지만 그 크기가 기존의 누적된 것보다 작아서 적절하게 부트스트래핑 과정을 수행한다면 지속적인 연산이 가능하다.\n이 방식은 원문을 비트 단위로 변환하여 각 비트별로 암호화하기 때문에 원문에 비해 암호문의 값이 10~100배가량 커져서 데이터의 저장 공간이 많이 필요하다. 그리고 개별 비트 단위로 암호문의 연산과 부트스트래핑 과정을 거쳐야 하기 때문에 연산 속도가 느리다.\n그래서 최근에는 효율성을 개선한 CRT 기반 완전 동형암호가 등장하였다. 이 방식은 하나의 원문을 특정한 정수인 암호키로 나눈 나머지 값을 암호문으로 이용하고, 이 나머지 값"
        },
        {
          "id": "c4",
          "text": "에서 원문을 복호화하는 방법이다. 이때 암호키의 개수는 임의로 설정할 수 있으며 각각의 원문마다 암호키의 개수만큼 암호문이 만들어진다. 암호키가 두 개일 때 정수로 된 원문 A와 B를 덧셈 연산한 결과가 동형성을 갖는 원리를 간단히 알아보자. 우선 서로소*인 임의의 정수 p와 q를 암호키로 정하고 정수로 된 원문 A와 B를 각각의 암호키로 나눈 나머지 값을 구하면 Ap, Aq와 Bp, Bq가 되는데 이 나머지 값이 원문 A와 B의 암호문이 된다. 그리고 <그림>처럼 각 원문을 동일한 암호키로 나눈 나머지 값인 Ap와 Bp, Aq와 Bq끼리 서로 덧셈 연산을 수행한다. 만약 연산 수행의 결괏값이 암호키와 같거나 암호키보다 크면 한 번 더 암호키로 나누어 나머지 값을 구한다. 그러면 연산 수행의 결괏값인 Ap+Bp, Aq+Bq가 원문 A와 B를 직접 덧셈 연산한 결괏값을 암호키 p와 q로 나눈 나머지 값인 (A+B)p, (A+B)q와 같다. 그리고 원문을 각 암호키로 나누었"
        },
        {
          "id": "c5",
          "text": "을 때의 나머지 값과 각 암호키를 알면 원문을 복호화할 수 있다. <그림>\n(원문 연산: A + B \\= A+B)\n(암호 연산: Ap + Bp \\= (A+B)p / Aq + Bq \\= (A+B)q)\n(Ap, Bp는 p로 나눈 나머지, Aq, Bq는 q로 나눈 나머지) 이 방식 또한 안전성을 위해서 암호키의 개수를 늘려 계산이 복잡하고 무작위로 오륫값을 추가하기 때문에 부트스트래핑 과정이 필요하다. 하지만 데이터를 정수 단위로 암호화하기 때문에 비트 단위로 암호화하는 격자 기반의 방식보다 더 많은 데이터를 저장할 수 있다. 또한 CRT 방식은 원문보다 작은 나머지 값으로 연산을 수행하기 때문에 격자 기반의 방식에 비해 연산 값이 상대적으로 작아 연산 속도가 빠르고, 격자 기반의 방식과 달리 병렬적으로 연산을 수행할 수 있다. * 비트: 정보량의 최소 기본 단위. 1비트는 이진수 체계(0, 1)의 한 자리.\n* 서로소: 여러 개의 수 사이에 1 이외의 공약수가 없음을 이르는"
        }
      ],
      "correctOrder": [
        "c1",
        "c2",
        "c3",
        "c4",
        "c5"
      ],
      "seedPenalty": 1
    },
    "confirm": {
      "questions": [
        {
          "id": "q1",
          "prompt": "지문에서 '인터넷상에서'를 찾아 클릭하세요.",
          "answerRanges": [
            {
              "paragraphId": "p1",
              "start": 25,
              "end": 31
            }
          ],
          "scoring": {
            "correctDeltaSec": 30,
            "wrongDeltaSec": -30
          },
          "revealOnWrong": true
        }
      ]
    }
  }
}
